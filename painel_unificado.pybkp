#!/usr/bin/env python3
import os
import sys
import json
import uuid
import time
import shutil
import threading
import subprocess
from flask import (
    Flask, render_template, request, jsonify, Response, redirect, url_for
)

app = Flask(__name__)

# --- Pastas base ---
BASE_DIR = os.path.dirname(os.path.abspath(__file__))

TOOLS_DIR = os.path.join(BASE_DIR, "tools")
UPLOAD_DIR = os.path.join(BASE_DIR, "uploads")
RESULTS_DIR = os.path.join(BASE_DIR, "results")
STATIC_DIR = os.path.join(BASE_DIR, "static")

for d in (UPLOAD_DIR, RESULTS_DIR):
    os.makedirs(d, exist_ok=True)

# --- Infra simples de SSE em memória ---
TASK_COND = {}
TASK_QUEUE = {}
TASK_TOOL = {}  # task_id -> "vazamento" | "metaweb" | "sherlock"


def _ensure_task(task_id: str, tool: str = None):
    if task_id not in TASK_COND:
        TASK_COND[task_id] = threading.Condition()
        TASK_QUEUE[task_id] = []
    if tool:
        TASK_TOOL[task_id] = tool


def _push_event(task_id: str, etype: str, payload: dict):
    _ensure_task(task_id)
    cond = TASK_COND[task_id]
    with cond:
        TASK_QUEUE[task_id].append((etype, payload))
        cond.notify_all()


def _sse_stream_named(task_id: str):
    """Stream SSE com eventos nomeados: 'progress', 'payload', 'complete', 'error'."""
    _ensure_task(task_id)
    cond = TASK_COND[task_id]
    idx = 0
    while True:
        with cond:
            if idx >= len(TASK_QUEUE[task_id]):
                cond.wait(timeout=30)
            if idx >= len(TASK_QUEUE[task_id]):
                yield ": keep-alive\n\n"
                continue
            etype, payload = TASK_QUEUE[task_id][idx]
            idx += 1

        yield f"event: {etype}\n"
        yield "data: " + json.dumps(payload, ensure_ascii=False) + "\n\n"

        if etype in ("complete", "error"):
            break


def _sse_stream_legacy(task_id: str, tool_name: str):
    """
    Stream SSE 'genérico' compatível com progress.html antigos,
    que usam evtSource.onmessage e esperam {tool, progress, final, message?, payload?}.
    """
    _ensure_task(task_id, tool=tool_name)
    cond = TASK_COND[task_id]
    idx = 0
    while True:
        with cond:
            if idx >= len(TASK_QUEUE[task_id]):
                cond.wait(timeout=30)
            if idx >= len(TASK_QUEUE[task_id]):
                yield ": keep-alive\n\n"
                continue
            etype, payload = TASK_QUEUE[task_id][idx]
            idx += 1

        base = {"tool": tool_name, "final": False}

        if etype == "progress":
            base["progress"] = int(payload.get("percent", 0))
            if "message" in payload:
                base["message"] = payload["message"]
        elif etype == "payload":
            base["progress"] = int(payload.get("percent", 100))
            base["payload"] = payload
        elif etype == "redirect":
            base["redirect_url"] = payload.get("url")
            base["progress"] = 100
        elif etype == "complete":
            base["progress"] = 100
            base["final"] = True
        elif etype == "error":
            base["progress"] = 100
            base["error"] = payload
            base["final"] = True
        else:
            base["payload"] = payload

        yield "data: " + json.dumps(base, ensure_ascii=False) + "\n\n"

        if etype in ("complete", "error"):
            break


# ========== ROTAS BÁSICAS ==========
@app.route("/")
def index():
    return render_template("index.html")


@app.route("/vazamento", methods=["GET"])
def email_leak():
    return render_template("vazamento.html")


@app.route("/metaweb", methods=["GET"])
def metaweb():
    return render_template("metaweb.html")


@app.route("/sherlock", methods=["GET"])
def sherlock_search():
    return render_template("sherlock.html")


@app.route("/ajuda", methods=["GET"])
def ajuda():
    return render_template("ajuda.html")


# ========== START (cria task e dispara thread) ==========
@app.route("/vazamento/start", methods=["POST"])
def vazamento_start():
    email = request.form.get("email", "").strip()
    if not email:
        return jsonify({"ok": False, "error": "Email não informado"}), 400
    task_id = str(uuid.uuid4())
    _ensure_task(task_id, tool="vazamento")
    threading.Thread(
        target=_run_vazamento_task, args=(task_id, email), daemon=True
    ).start()

    # opcional: abrir tela de progresso dedicada
    if request.headers.get("Accept", "").find("json") == -1 and request.args.get("redirect") == "1":
        return redirect(url_for("vazamento_exec", task_id=task_id))
    return jsonify({"ok": True, "task_id": task_id})


@app.route("/metaweb/start", methods=["POST"])
def metaweb_start():
    file = request.files.get("file")
    if not file:
        return jsonify({"ok": False, "error": "Arquivo não enviado"}), 400
    uid = str(uuid.uuid4())
    safe_name = f"{uid}__{os.path.basename(file.filename)}"
    save_path = os.path.join(UPLOAD_DIR, safe_name)
    file.save(save_path)
    task_id = str(uuid.uuid4())
    _ensure_task(task_id, tool="metaweb")
    threading.Thread(
        target=_run_metaweb_task, args=(task_id, save_path), daemon=True
    ).start()
    return jsonify({"ok": True, "task_id": task_id})


@app.route("/sherlock/start", methods=["POST"])
def sherlock_start():
    username = request.form.get("username", "").strip()
    include_nsfw = bool(request.form.get("nsfw"))
    if not username:
        return jsonify({"ok": False, "error": "Nome de usuário não informado"}), 400
    task_id = str(uuid.uuid4())
    _ensure_task(task_id, tool="sherlock")
    threading.Thread(
        target=_run_sherlock_task, args=(task_id, username, include_nsfw), daemon=True
    ).start()
    return jsonify({"ok": True, "task_id": task_id})


# ========== PÁGINAS DE PROGRESSO ==========
@app.route("/vazamento/exec/<task_id>")
def vazamento_exec(task_id):
    return render_template("vazamento_progress.html", exec_id=task_id)


# ========== SSE ==========
# SSE nomeado para Vazamento
@app.route("/sse/vazamento/<task_id>")
def sse_vazamento_named(task_id):
    return Response(_sse_stream_named(task_id), mimetype="text/event-stream")


# SSE nomeado para Metaweb
@app.route("/sse/metaweb/<task_id>")
def sse_metaweb_named(task_id):
    return Response(_sse_stream_named(task_id), mimetype="text/event-stream")


# Compatível com vazamento_progress.html antigo (evtSource.onmessage)
@app.route("/vazamento/progress")
def sse_vazamento_legacy():
    task_id = request.args.get("exec_id", "")
    if not task_id:
        return "Missing exec_id", 400
    return Response(_sse_stream_legacy(task_id, "vazamento"), mimetype="text/event-stream")


# Mantém compatibilidade com Sherlock (nomeado)
@app.route("/sse/sherlock/<task_id>")
def sse_sherlock(task_id):
    return Response(_sse_stream_named(task_id), mimetype="text/event-stream")


# Endpoint SSE genérico (se quiser unificar)
@app.route("/sse/<task_id>")
def sse_generic(task_id):
    return Response(_sse_stream_named(task_id), mimetype="text/event-stream")


# ========== RESULTADOS ==========
@app.route("/vazamento/result/<task_id>")
def vazamento_result_page(task_id):
    rel_json = os.path.join(BASE_DIR, "leak_check_results", "ultimo_relatorio.json")
    if not os.path.exists(rel_json):
        return render_template(
            "vazamento_result.html",
            dados={"email": "-", "data": "-"},
            resultados=[]
        )

    with open(rel_json, "r", encoding="utf-8") as f:
        data = json.load(f)

    email = data.get("email", "-")
    data_id = data.get("data", "-")
    resultados_dict = data.get("resultados", {})

    resultados = []
    for fonte, arquivo in resultados_dict.items():
        link = f"/static/relatorios/{data_id}/{arquivo}"
        conteudo = ""
        arq_path = os.path.join(STATIC_DIR, "relatorios", data_id, arquivo)
        try:
            if os.path.exists(arq_path):
                with open(arq_path, "r", encoding="utf-8", errors="ignore") as fh:
                    conteudo = fh.read()
                    if len(conteudo) > 15000:
                        conteudo = conteudo[:15000] + "\n<!-- (conteúdo truncado) -->"
        except Exception:
            pass

        resultados.append({
            "fonte": fonte,
            "status": "OK",
            "link": link,
            "conteudo": conteudo
        })

    return render_template(
        "vazamento_result.html",
        dados={"email": email, "data": data_id},
        resultados=resultados
    )


# ========== IMPLEMENTAÇÕES DAS TASKS ==========

def _run_vazamento_task(task_id: str, email: str):
    """
    Executa o script bash de vazamento de e-mails e envia progresso via SSE.
    """
    _push_event(task_id, "progress", {"percent": 1, "message": "Iniciando verificação..."})
    script = os.path.join(TOOLS_DIR, "email_leak_checker_full.sh")
    if not os.path.exists(script):
        _push_event(task_id, "error", {"message": "Script de vazamento não encontrado"})
        return

    try:
        proc = subprocess.Popen(
            ["/bin/bash", script, email],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )
        stdout_acc, stderr_acc = [], []
        percent = 5
        last_emit = time.time()

        while True:
            line = proc.stdout.readline()
            if line:
                stdout_acc.append(line.rstrip())
                now = time.time()
                if now - last_emit > 0.5:
                    percent = min(percent + 5, 90)
                    _push_event(task_id, "progress", {"percent": percent, "message": "Rodando verificações..."})
                    last_emit = now
            elif proc.poll() is not None:
                break

        if proc.stderr:
            stderr_acc.append(proc.stderr.read())

        code = proc.wait()
        if code != 0:
            _push_event(task_id, "error", {"message": f"Script terminou com código {code}", "stderr": "".join(stderr_acc)})
            return

        # Carregar JSON final
        rel_json = os.path.join(BASE_DIR, "leak_check_results", "ultimo_relatorio.json")
        dados = {}
        if os.path.exists(rel_json):
            with open(rel_json, "r", encoding="utf-8") as f:
                dados = json.load(f)

        _push_event(task_id, "progress", {"percent": 95, "message": "Consolidando resultados..."})
        _push_event(task_id, "payload", {"dados": dados, "resumo": f"Verificação concluída para {email}"})
        _push_event(task_id, "complete", {"ok": True})

    except Exception as e:
        _push_event(task_id, "error", {"message": f"Falha ao executar vazamento: {e}"})


def _run_metaweb_task(task_id: str, filepath: str):
    def run_cmd(label, cmd_list):
        if not shutil.which(cmd_list[0]):
            return f"[{label}] Comando '{cmd_list[0]}' não encontrado."
        try:
            return subprocess.check_output(cmd_list, stderr=subprocess.STDOUT, text=True).strip()
        except subprocess.CalledProcessError as e:
            return f"[{label}] Erro ({e.returncode}):\n{e.output}"

    resultado = {}
    etapas = [
        ("file", ["file", filepath]),
        ("exiftool", ["exiftool", filepath]),
        ("strings", ["strings", "-n", "8", filepath]),
        ("md5sum", ["md5sum", filepath]),
        ("sha256sum", ["sha256sum", filepath])
    ]
    percent_step = max(1, int(90 / len(etapas)))
    percent = 1
    _push_event(task_id, "progress", {"percent": percent, "message": "Iniciando análise de metadados..."})

    for nome, cmd in etapas:
        percent = min(percent + percent_step, 90)
        _push_event(task_id, "progress", {"percent": percent, "message": f"Rodando '{nome}'..."})
        resultado[nome] = run_cmd(nome, cmd)

    _push_event(task_id, "progress", {"percent": 95, "message": "Consolidando resultados..."})
    _push_event(task_id, "payload", {"resultado": resultado})
    _push_event(task_id, "complete", {"ok": True})


def _run_sherlock_task(task_id: str, username: str, include_nsfw: bool):
    """
    Alteração segura: usamos o runner local tools/sherlock_runner.py que está no seu repo.
    Isso evita problemas de -m vs caminho de módulo e preserva saída já usada pelo frontend.
    """
    _push_event(task_id, "progress", {"percent": 1, "message": "Preparando Sherlock..."})

    py = sys.executable or "python3"
    runner = os.path.join(TOOLS_DIR, "sherlock_runner.py")
    if not os.path.exists(runner):
        # fallback: tentar módulo sherlock (mais frágil)
        cmd = [py, "-m", "sherlock", username, "--print-found", "--no-color"]
    else:
        cmd = [py, runner, username]
        if include_nsfw:
            # nosso runner não usa flag nsfw por padrão — mas podemos passar via env ou argumento
            cmd.append("--nsfw")

    _push_event(task_id, "progress", {"percent": 15, "message": "Executando busca..."})
    try:
        proc = subprocess.Popen(
            cmd,
            cwd=TOOLS_DIR,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )
        stdout_acc = []
        stderr_acc = []
        last_emit = time.time()
        percent = 15
        while True:
            line = proc.stdout.readline()
            if line:
                stdout_acc.append(line.rstrip())
                now = time.time()
                if now - last_emit > 0.4:
                    percent = min(percent + 3, 85)
                    _push_event(task_id, "progress", {"percent": percent, "message": "Analisando plataformas..."})
                    last_emit = now
            elif proc.poll() is not None:
                break

        if proc.stderr:
            stderr_acc.append(proc.stderr.read())
        code = proc.wait()
        if code != 0:
            _push_event(task_id, "error", {"message": f"Sherlock terminou com código {code}.", "stderr": "".join(stderr_acc)})
            return

        _push_event(task_id, "progress", {"percent": 95, "message": "Finalizando..."})
        _push_event(task_id, "payload", {
            "resultado": "\n".join(stdout_acc),
            "stderr": "".join(stderr_acc)
        })
        _push_event(task_id, "complete", {"ok": True})
    except Exception as e:
        _push_event(task_id, "error", {"message": f"Falha ao executar Sherlock: {e}"})

def _run_vazamento_task(task_id: str, email: str):
    """
    Executa o script bash de vazamento de e-mails e envia progresso via SSE.
    """
    _push_event(task_id, "progress", {"percent": 1, "message": "Iniciando verificação..."})
    script = os.path.join(TOOLS_DIR, "email_leak_checker_full.sh")
    if not os.path.exists(script):
        _push_event(task_id, "error", {"message": "Script de vazamento não encontrado"})
        return

    try:
        proc = subprocess.Popen(
            ["/bin/bash", script, email],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )
        stdout_acc, stderr_acc = [], []
        percent = 5
        last_emit = time.time()

        while True:
            line = proc.stdout.readline()
            if line:
                stdout_acc.append(line.rstrip())
                now = time.time()
                if now - last_emit > 0.5:
                    percent = min(percent + 5, 90)
                    _push_event(task_id, "progress", {"percent": percent, "message": "Rodando verificações..."})
                    last_emit = now
            elif proc.poll() is not None:
                break

        if proc.stderr:
            stderr_acc.append(proc.stderr.read())

        code = proc.wait()
        if code != 0:
            _push_event(task_id, "error", {"message": f"Script terminou com código {code}", "stderr": "".join(stderr_acc)})
            return

        # Carregar JSON final
        rel_json = os.path.join(BASE_DIR, "leak_check_results", "ultimo_relatorio.json")
        dados = {}
        if os.path.exists(rel_json):
            with open(rel_json, "r", encoding="utf-8") as f:
                dados = json.load(f)

        _push_event(task_id, "progress", {"percent": 95, "message": "Consolidando resultados..."})
        _push_event(task_id, "payload", {"dados": dados, "resumo": f"Verificação concluída para {email}"})
        _push_event(task_id, "complete", {"ok": True})

    except Exception as e:
        _push_event(task_id, "error", {"message": f"Falha ao executar vazamento: {e}"})


# ========== MAIN ==========
if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5050, debug=False)
